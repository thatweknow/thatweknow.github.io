---
title: K8s开发相关 6343ef0392914c3681ce1b42cde1eb95
date: 2024-11-02 17:12:48
top: false
cover: false
toc: true
mathjax: false
categories: common
tags:
  - common
--- 
 
# K8s开发相关

# 1、k8s  yml  apiverison:

Kubernetes (k8s) 的 API 版本表示资源定义在 API 服务器中的稳定性和支持程度。API 版本由一个字符串表示，如 **`v1`** 或 **`apps/v1`**，其中包括两个部分：

1. **组** (Group): 如果资源属于某个 API 组，则该字段表示该组的名称。例如，**`apps`** 表示应用程序相关的资源如 Deployments。
2. **版本** (Version): 表示 API 的版本，常见的有 **`v1`**、**`v1beta1`** 等。

### **常见的 API 版本有：**

- **v1**: 核心组的稳定版本，包括常用的资源如 Pods、Services、ConfigMaps 和 Secrets。
- **apps/v1**: 用于管理应用的稳定版本，包括 Deployments、StatefulSets、DaemonSets 等。
- **batch/v1**: 用于批处理任务，包括 Job 资源。
- **batch/v1beta1**: 包括 CronJob 资源。
- **extensions/v1beta1**: 早期版本的一些资源，例如 Ingress（现在推荐使用 **`networking.k8s.io/v1`**）。
- **networking.k8s.io/v1**: 网络相关资源，包括 NetworkPolicies 和 Ingresses。
- **rbac.authorization.k8s.io/v1**: 用于角色基础访问控制的资源，包括 Roles 和 RoleBindings。
- **storage.k8s.io/v1**: 存储相关的资源，包括 StorageClasses 和 VolumeAttachments。
- **autoscaling/v1**: 自动缩放相关资源，包括 HorizontalPodAutoscalers。
- **policy/v1beta1**: 包括 PodSecurityPolicies，用于定义 Pod 的安全性相关设置。

# 2、开发人员比较常用的一些 Kubernetes  Kind类型：

### 核心资源类型

1. **Pod**: 作为应用的最小和最简单的单元，每个 Pod 包含一个或多个容器。
2. **Service**: 提供稳定的 IP 地址和 DNS 名称，将外部网络流量路由到后端的 Pod。
3. **Deployment**: 用来描述应用的期望状态，Kubernetes 会确保真实状态符合期望状态。
4. **ConfigMap**: 存储非敏感数据的键值对，可以用来存储环境变量、配置文件等信息。
5. **Secret**: 存储敏感数据，如密码、OAuth 令牌等。
6. **PersistentVolume** 和 **PersistentVolumeClaim**: 提供 Pod 持久化存储的能力。
7. **Namespace**: 提供一种将集群资源分隔成多个独立的部分的方式。

### 配置和管理资源类型

1. **ResourceQuota**: 确保每个命名空间下的资源使用量不超过设定的配额。
2. **LimitRange**: 限制命名空间下资源的大小，请求和限制。
3. **HorizontalPodAutoscaler**: 根据 CPU 使用或其他选择的度量自动缩放 Pod 的数量。

### 网络资源类型

1. **Ingress**: 为服务提供外部可访问的 URL，负载均衡，SSL/TLS 终止等。
2. **NetworkPolicy**: 定义 Pod 间通信的网络策略。

### 其他资源类型

1. **Job** 和 **CronJob**: 用于执行一次性或周期性的任务。
2. **StatefulSet**: 用于运行需要持久存储和唯一网络标识符的应用。
3. **DaemonSet**: 确保所有（或部分）节点运行一个 Pod 的副本。
4. **ReplicaSet**: 确保指定数量的 Pod 副本始终可用。
5. **Node**: 表示集群中的一个节点。

开发人员在使用 Kubernetes 时，通常会涉及到这些资源的创建和管理。通过这些资源，他们可以定义和配置应用的运行环境，实现自动化和弹性伸缩等特性。理解这些资源的作用和使用方式，是开发人员在 Kubernetes 平台上高效工作的基础。

# 3、开发常用的配置文件的模版

### 标准结构

```yaml
apiVersion: <string>
kind: <string>
metadata:
  name: <string>
  namespace: <string>
  labels:
    <key>: <value>
  annotations:
    <key>: <value>
spec:
  ...
status:
  ...

```

### 字段解释

- **apiVersion** (必选): 指定 Kubernetes API 的版本，用于确定使用哪个版本的 API 来创建该资源。
- **kind** (必选): 指定资源的类型，例如 Pod、Service、Deployment 等。
- **metadata** (必选): 提供资源的元数据，包括名称、命名空间和标签等。
    - **name** (必选): 资源的唯一名称。
    - **namespace** (可选): 指定资源所属的命名空间。
    - **labels** (可选): 键值对，用于组织和选择资源。
    - **annotations** (可选): 键值对，用于存储非标识性的元数据。
- **spec** (根据资源类型，可能是必选或可选): 指定资源的期望状态，包括所需的配置参数。
- **status** (可选): 描述资源的当前状态。通常由 Kubernetes 系统维护和更新。

### spec 字段

`spec` 字段的内容高度依赖于资源的 `kind` 类型。以下是一些常见资源类型的 `spec` 字段示例：

- **Pod**:
    
    ```yaml
    spec:
      containers:
      - name: <container-name>
        image: <container-image>
        ports:
        - containerPort: <port-number>
    
    ```
    
- **Service**:
    
    ```yaml
    spec:
      selector:
        <label-key>: <label-value>
      ports:
      - protocol: TCP
        port: <port-number>
        targetPort: <target-port-number>
    
    ```
    
- **Deployment**:
    
    ```yaml
    spec:
      replicas: <number-of-replicas>
      selector:
        matchLabels:
          <label-key>: <label-value>
      template:
        metadata:
          labels:
            <label-key>: <label-value>
        spec:
          containers:
          - name: <container-name>
            image: <container-image>
    
    ```
    
- ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: <string>
  namespace: <string>
  labels:
    <key>: <value>
  annotations:
    <key>: <value>
data:   # ConfigMap\Secret 特有的
  <key>: <value>

```

- Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: <string>
  namespace: <string>
  labels:
    <key>: <value>
  annotations:
    <key>: <value>
spec:
  ingressClassName: <string>
  defaultBackend:
    service:
      name: <string>
      port:
        number: <integer>
    resource:
      apiGroup: <string>
      kind: <string>
      name: <string>
  tls:
    - hosts:
        - <string>
      secretName: <string>
  rules:
    - host: <string>
      http:
        paths:
          - path: <string>
            pathType: <string>
            backend:
              service:
                name: <string>
                port:
                  name: <string>
                  number: <integer>
              resource:
                apiGroup: <string>
                kind: <string>
                name: <string>
status:
  loadBalancer:
    ingress:
      - ip: <string>
        hostname: <string>

```

# 4、Deployment和StatefulSet的区别

`StatefulSet` 和 `Deployment` 是 Kubernetes 中两种不同类型的资源控制器，它们用于管理 Pod 的生命周期，但它们主要用于不同的场景，并提供不同的功能。

### Deployment

1. **无状态应用**: `Deployment` 适用于无状态的应用。这意味着单个 Pod 的实例是可以互换的，它们不需要保持任何持久状态。
2. **副本**: 通过 `Deployment` 创建的所有 Pod 副本都是相同的。
3. **滚动更新**: `Deployment` 支持滚动更新，可以在不停止服务的情况下更新应用。
4. **快速扩展**: 适用于需要快速启动或缩容的应用。
5. **生命周期管理**: `Deployment` 确保指定数量的 Pod 副本始终处于运行状态。

### StatefulSet

1. **有状态应用**: `StatefulSet` 适用于需要持久存储和特定网络标识的有状态应用。
2. **稳定的网络标识**: 每个 Pod 副本都有一个稳定的、唯一的网络标识符。
3. **稳定的存储**: 即使 Pod 被重新调度到不同的节点，它也能保持对存储卷的访问。
4. **有序部署**: `StatefulSet` 保证 Pod 是按顺序创建和删除的。
5. **有序扩展**: 当扩展或缩容时，`StatefulSet` 确保操作是按照顺序进行的。

### 用例对比

- **无状态应用**: 如果你的应用不需要保存状态、快速扩展和缩容，以及滚动更新，那么 `Deployment` 更适合。
- **有状态应用**: 如果你的应用需要稳定的网络标识、稳定的持久存储和有序、优雅的部署和扩展，那么 `StatefulSet` 更适合。

总的来说，选择 `StatefulSet` 或 `Deployment` 取决于你的应用是否需要保持状态以及你对网络标识和存储的需求。

# 5、apollo部署实例

下面是一个使用Kubernetes部署Apollo的例子，包括一个Pod、一个Service和一个Deployment。

1. **Deployment**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: apollo
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: apollo
  template:
    metadata:
      labels:
        app: apollo
    spec:
      containers:
      - name: apollo
        image: apolloconfig/apollo-portal:latest
        env:
        - name: SPRING_DATASOURCE_URL
          value: jdbc:mysql://your-mysql-server:3306/ApolloConfigDB?characterEncoding=utf8
        - name: SPRING_DATASOURCE_USERNAME
          value: yourusername
        - name: SPRING_DATASOURCE_PASSWORD
          value: yourpassword
        ports:
        - containerPort: 8070

# ---
# apiVersion: v1
# kind: Service
# metadata:
```

1. **Service**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: apollo-service
  namespace: default
spec:
  selector:
    app: apollo
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8070
  type: ClusterIP

```

1. **Pod**
Pods通常由Deployment管理，但如果你要创建单独的Pod：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: apollo-pod
  labels:
    app: apollo
spec:
  containers:
  - name: apollo
    image: apolloconfig/apollo-portal:latest
    env:
    - name: SPRING_DATASOURCE_URL
      value: jdbc:mysql://your-mysql-server:3306/ApolloConfigDB?characterEncoding=utf8
    - name: SPRING_DATASOURCE_USERNAME
      value: yourusername
    - name: SPRING_DATASOURCE_PASSWORD
      value: yourpassword
    ports:
    - containerPort: 8070

```

在这个例子里面,  service和deployment是分开写的， 你也可以写到一块。

当你在创建 Service 时，Kubernetes 不要求对应的 Pod 或 Deployment 已经存在。Service 会持续地监听并动态地更新其选择的 Pod 列表。这意味着你可以先创建 Service，再创建 Deployment，Service 会自动发现并开始转发流量到正确的 Pod。

1. **如果先创建 Service：** Service 会一直等待，直到有符合其标签选择器的 Pod 被创建，然后它会开始转发流量到这些 Pod。
2. **如果先创建 Deployment：** Pod 会被创建，并且等待 Service 被创建。一旦 Service 创建并且其标签选择器正确配置，它就会开始转发流量到这些 Pod。

# 6、Kubernetes 的核心组件的实现

1. **容器runtime**:
    - Kubernetes 支持多种容器运行时，包括 Docker 和 containerd。容器运行时负责在节点上运行和管理容器。它们实现了 [OCI(Open Container Initiative)](https://opencontainers.org/) 标准，以确保跨不同环境的一致性和可移植性。
2. **容器编排**:
    - Kubernetes 的编排功能通过其控制平面中的各种控制器和调度器实现。例如，ReplicaSet 控制器确保指定数量的副本始终在运行，而 Deployment 控制器可以帮助管理应用程序的更新和回滚。
3. **容器中心的基础架构编排**:
    - Kubernetes 通过其网络和存储抽象实现了基础架构编排。例如，它提供了 Service 和 Ingress 对象来管理网络通信，以及 PersistentVolume 和 PersistentVolumeClaim 对象来管理存储资源。
4. **自愈机制**:
    - Kubernetes 通过其控制器和健康检查机制实现自愈功能。例如，如果一个节点变得不健康，Kubernetes 可以自动重新调度该节点上的 Pod 到其他健康节点。
5. **服务发现和负载均衡**:
    - Kubernetes 通过其 Service 和 Ingress 对象实现服务发现和负载均衡。Service 对象提供了一个稳定的网络地址，用于访问一个或多个 Pod，而 Ingress 对象提供了 HTTP 和 HTTPS 路由到集群内的服务。